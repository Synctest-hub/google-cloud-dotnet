// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/places/v1/places_service.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Maps.Places.V1 {

  /// <summary>Holder for reflection information generated from google/maps/places/v1/places_service.proto</summary>
  public static partial class PlacesServiceReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/places/v1/places_service.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PlacesServiceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cipnb29nbGUvbWFwcy9wbGFjZXMvdjEvcGxhY2VzX3NlcnZpY2UucHJvdG8S",
            "FWdvb2dsZS5tYXBzLnBsYWNlcy52MRocZ29vZ2xlL2FwaS9hbm5vdGF0aW9u",
            "cy5wcm90bxoXZ29vZ2xlL2FwaS9jbGllbnQucHJvdG8aH2dvb2dsZS9hcGkv",
            "ZmllbGRfYmVoYXZpb3IucHJvdG8aHmdvb2dsZS9nZW8vdHlwZS92aWV3cG9y",
            "dC5wcm90bxokZ29vZ2xlL21hcHMvcGxhY2VzL3YxL2dlb21ldHJ5LnByb3Rv",
            "GiFnb29nbGUvbWFwcy9wbGFjZXMvdjEvcGxhY2UucHJvdG8iQAoKSW50MzJS",
            "YW5nZRIQCgNtaW4YASABKAVIAIgBARIQCgNtYXgYAiABKAVIAYgBAUIGCgRf",
            "bWluQgYKBF9tYXgigAgKEVNlYXJjaFRleHRSZXF1ZXN0EhcKCnRleHRfcXVl",
            "cnkYASABKAlCA+BBAhIVCg1sYW5ndWFnZV9jb2RlGAIgASgJEhMKC3JlZ2lv",
            "bl9jb2RlGAMgASgJElAKD3JhbmtfcHJlZmVyZW5jZRgEIAEoDjI3Lmdvb2ds",
            "ZS5tYXBzLnBsYWNlcy52MS5TZWFyY2hUZXh0UmVxdWVzdC5SYW5rUHJlZmVy",
            "ZW5jZRJHCghsb2NhdGlvbhgFIAEoCzIxLmdvb2dsZS5tYXBzLnBsYWNlcy52",
            "MS5TZWFyY2hUZXh0UmVxdWVzdC5Mb2NhdGlvbkICGAESFQoNaW5jbHVkZWRf",
            "dHlwZRgGIAEoCRIQCghvcGVuX25vdxgHIAEoCBI6CgtwcmljZV9yYW5nZRgI",
            "IAEoCzIhLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5JbnQzMlJhbmdlQgIYARIS",
            "CgptaW5fcmF0aW5nGAkgASgBEhgKEG1heF9yZXN1bHRfY291bnQYCiABKAUS",
            "NwoMcHJpY2VfbGV2ZWxzGAsgAygOMiEuZ29vZ2xlLm1hcHMucGxhY2VzLnYx",
            "LlByaWNlTGV2ZWwSHQoVc3RyaWN0X3R5cGVfZmlsdGVyaW5nGAwgASgIEkwK",
            "DWxvY2F0aW9uX2JpYXMYDSABKAsyNS5nb29nbGUubWFwcy5wbGFjZXMudjEu",
            "U2VhcmNoVGV4dFJlcXVlc3QuTG9jYXRpb25CaWFzEloKFGxvY2F0aW9uX3Jl",
            "c3RyaWN0aW9uGA4gASgLMjwuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlNlYXJj",
            "aFRleHRSZXF1ZXN0LkxvY2F0aW9uUmVzdHJpY3Rpb24aXgoITG9jYXRpb24S",
            "LgoJcmVjdGFuZ2xlGAEgASgLMhkuZ29vZ2xlLmdlby50eXBlLlZpZXdwb3J0",
            "SAASGgoSc3RyaWN0X3Jlc3RyaWN0aW9uGAIgASgIQgYKBHR5cGUadwoMTG9j",
            "YXRpb25CaWFzEi4KCXJlY3RhbmdsZRgBIAEoCzIZLmdvb2dsZS5nZW8udHlw",
            "ZS5WaWV3cG9ydEgAEi8KBmNpcmNsZRgCIAEoCzIdLmdvb2dsZS5tYXBzLnBs",
            "YWNlcy52MS5DaXJjbGVIAEIGCgR0eXBlGk0KE0xvY2F0aW9uUmVzdHJpY3Rp",
            "b24SLgoJcmVjdGFuZ2xlGAEgASgLMhkuZ29vZ2xlLmdlby50eXBlLlZpZXdw",
            "b3J0SABCBgoEdHlwZSJOCg5SYW5rUHJlZmVyZW5jZRIfChtSQU5LX1BSRUZF",
            "UkVOQ0VfVU5TUEVDSUZJRUQQABIMCghESVNUQU5DRRABEg0KCVJFTEVWQU5D",
            "RRACIkIKElNlYXJjaFRleHRSZXNwb25zZRIsCgZwbGFjZXMYASADKAsyHC5n",
            "b29nbGUubWFwcy5wbGFjZXMudjEuUGxhY2UyoQEKBlBsYWNlcxJ9CgpTZWFy",
            "Y2hUZXh0EiguZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlNlYXJjaFRleHRSZXF1",
            "ZXN0GikuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlNlYXJjaFRleHRSZXNwb25z",
            "ZSIagtPkkwIUIg8vdjEvVGV4dDpzZWFyY2g6ASoaGMpBFXBsYWNlcy5nb29n",
            "bGVhcGlzLmNvbUKmAQoZY29tLmdvb2dsZS5tYXBzLnBsYWNlcy52MUISUGxh",
            "Y2VzU2VydmljZVByb3RvUAFaN2Nsb3VkLmdvb2dsZS5jb20vZ28vbWFwcy9w",
            "bGFjZXMvYXBpdjEvcGxhY2VzcGI7cGxhY2VzcGL4AQGiAgZHTVBTVjGqAhVH",
            "b29nbGUuTWFwcy5QbGFjZXMuVjHKAhVHb29nbGVcTWFwc1xQbGFjZXNcVjFi",
            "BnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Geo.Type.ViewportReflection.Descriptor, global::Google.Maps.Places.V1.GeometryReflection.Descriptor, global::Google.Maps.Places.V1.PlaceReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.Int32Range), global::Google.Maps.Places.V1.Int32Range.Parser, new[]{ "Min", "Max" }, new[]{ "Min", "Max" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest), global::Google.Maps.Places.V1.SearchTextRequest.Parser, new[]{ "TextQuery", "LanguageCode", "RegionCode", "RankPreference", "Location", "IncludedType", "OpenNow", "PriceRange", "MinRating", "MaxResultCount", "PriceLevels", "StrictTypeFiltering", "LocationBias", "LocationRestriction" }, null, new[]{ typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.Location), global::Google.Maps.Places.V1.SearchTextRequest.Types.Location.Parser, new[]{ "Rectangle", "StrictRestriction" }, new[]{ "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias), global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias.Parser, new[]{ "Rectangle", "Circle" }, new[]{ "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction), global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction.Parser, new[]{ "Rectangle" }, new[]{ "Type" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextResponse), global::Google.Maps.Places.V1.SearchTextResponse.Parser, new[]{ "Places" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// int 32 range. Both min and max are optional. If only min is set, then the
  /// range only has a lower bound. If only max is set, then range only has an
  /// upper bound. At least one of min and max must be set. Values are inclusive.
  /// </summary>
  public sealed partial class Int32Range : pb::IMessage<Int32Range>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Int32Range> _parser = new pb::MessageParser<Int32Range>(() => new Int32Range());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Int32Range> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int32Range() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int32Range(Int32Range other) : this() {
      _hasBits0 = other._hasBits0;
      min_ = other.min_;
      max_ = other.max_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int32Range Clone() {
      return new Int32Range(this);
    }

    /// <summary>Field number for the "min" field.</summary>
    public const int MinFieldNumber = 1;
    private int min_;
    /// <summary>
    /// Lower bound. If unset, behavior is documented on the range field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Min {
      get { if ((_hasBits0 & 1) != 0) { return min_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        min_ = value;
      }
    }
    /// <summary>Gets whether the "min" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "min" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "max" field.</summary>
    public const int MaxFieldNumber = 2;
    private int max_;
    /// <summary>
    /// Upper bound. If unset, behavior is documented on the range field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Max {
      get { if ((_hasBits0 & 2) != 0) { return max_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        max_ = value;
      }
    }
    /// <summary>Gets whether the "max" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMax {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "max" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMax() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Int32Range);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Int32Range other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Min != other.Min) return false;
      if (Max != other.Max) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMin) hash ^= Min.GetHashCode();
      if (HasMax) hash ^= Max.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMin) {
        output.WriteRawTag(8);
        output.WriteInt32(Min);
      }
      if (HasMax) {
        output.WriteRawTag(16);
        output.WriteInt32(Max);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMin) {
        output.WriteRawTag(8);
        output.WriteInt32(Min);
      }
      if (HasMax) {
        output.WriteRawTag(16);
        output.WriteInt32(Max);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMin) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Min);
      }
      if (HasMax) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Max);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Int32Range other) {
      if (other == null) {
        return;
      }
      if (other.HasMin) {
        Min = other.Min;
      }
      if (other.HasMax) {
        Max = other.Max;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Min = input.ReadInt32();
            break;
          }
          case 16: {
            Max = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Min = input.ReadInt32();
            break;
          }
          case 16: {
            Max = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request data structure for SearchText.
  /// </summary>
  public sealed partial class SearchTextRequest : pb::IMessage<SearchTextRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchTextRequest> _parser = new pb::MessageParser<SearchTextRequest>(() => new SearchTextRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchTextRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextRequest(SearchTextRequest other) : this() {
      textQuery_ = other.textQuery_;
      languageCode_ = other.languageCode_;
      regionCode_ = other.regionCode_;
      rankPreference_ = other.rankPreference_;
      location_ = other.location_ != null ? other.location_.Clone() : null;
      includedType_ = other.includedType_;
      openNow_ = other.openNow_;
      priceRange_ = other.priceRange_ != null ? other.priceRange_.Clone() : null;
      minRating_ = other.minRating_;
      maxResultCount_ = other.maxResultCount_;
      priceLevels_ = other.priceLevels_.Clone();
      strictTypeFiltering_ = other.strictTypeFiltering_;
      locationBias_ = other.locationBias_ != null ? other.locationBias_.Clone() : null;
      locationRestriction_ = other.locationRestriction_ != null ? other.locationRestriction_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextRequest Clone() {
      return new SearchTextRequest(this);
    }

    /// <summary>Field number for the "text_query" field.</summary>
    public const int TextQueryFieldNumber = 1;
    private string textQuery_ = "";
    /// <summary>
    /// Required. The text query for textual search.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TextQuery {
      get { return textQuery_; }
      set {
        textQuery_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "language_code" field.</summary>
    public const int LanguageCodeFieldNumber = 2;
    private string languageCode_ = "";
    /// <summary>
    /// Place details will be displayed with the preferred language if available.
    /// If the language code is unspecified or unrecognized, place details of any
    /// language may be returned, with a preference for English if such details
    /// exist.
    ///
    /// Current list of supported languages:
    /// https://developers.google.com/maps/faq#languagesupport.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LanguageCode {
      get { return languageCode_; }
      set {
        languageCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "region_code" field.</summary>
    public const int RegionCodeFieldNumber = 3;
    private string regionCode_ = "";
    /// <summary>
    /// The Unicode country/region code (CLDR) of the location where the
    /// request is coming from. It is used to display the place details, like
    /// region-specific place name, if available.
    ///
    /// For more information, see
    /// http://www.unicode.org/reports/tr35/#unicode_region_subtag.
    ///
    /// Note that 3-digit region codes are not currently supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RegionCode {
      get { return regionCode_; }
      set {
        regionCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "rank_preference" field.</summary>
    public const int RankPreferenceFieldNumber = 4;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference rankPreference_ = global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified;
    /// <summary>
    /// How results will be ranked in the response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference RankPreference {
      get { return rankPreference_; }
      set {
        rankPreference_ = value;
      }
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 5;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.Location location_;
    /// <summary>
    /// The region to search. Setting location would usually yields
    /// better results. Recommended to set. This location serves as a bias unless
    /// strict_restriction is set to true, which turns the location to a strict
    /// restriction.
    ///
    /// Deprecated.  Use LocationRestriction or LocationBias instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.Location Location {
      get { return location_; }
      set {
        location_ = value;
      }
    }

    /// <summary>Field number for the "included_type" field.</summary>
    public const int IncludedTypeFieldNumber = 6;
    private string includedType_ = "";
    /// <summary>
    /// The requested place type. Full list of types supported:
    /// https://developers.google.com/places/supported_types. Only support one
    /// included type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IncludedType {
      get { return includedType_; }
      set {
        includedType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "open_now" field.</summary>
    public const int OpenNowFieldNumber = 7;
    private bool openNow_;
    /// <summary>
    /// Used to restrict the search to places that are open at a specific time.
    /// open_now marks if a business is currently open.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OpenNow {
      get { return openNow_; }
      set {
        openNow_ = value;
      }
    }

    /// <summary>Field number for the "price_range" field.</summary>
    public const int PriceRangeFieldNumber = 8;
    private global::Google.Maps.Places.V1.Int32Range priceRange_;
    /// <summary>
    /// [Deprecated!]Used to restrict the search to places that are within a
    /// certain price range. This is on a scale of 0 to 4. Set a minimum of 0 or
    /// set a maximum of 4 has no effect on the search results. Min price is
    /// default to 0 and max price is default to 4. Default value will be used if
    /// either min or max is unset.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.Int32Range PriceRange {
      get { return priceRange_; }
      set {
        priceRange_ = value;
      }
    }

    /// <summary>Field number for the "min_rating" field.</summary>
    public const int MinRatingFieldNumber = 9;
    private double minRating_;
    /// <summary>
    /// Filter out results whose average user rating is strictly less than this
    /// limit. A valid value must be an float between 0 and 5 (inclusively) at a
    /// 0.5 cadence i.e. `[0, 0.5, 1.0, ... , 5.0]` inclusively. This is to keep
    /// parity with LocalRefinement_UserRating. The input rating will round up to
    /// the nearest 0.5(ceiling). For instance, a rating of 0.6 will eliminate all
    /// results with a less than 1.0 rating.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double MinRating {
      get { return minRating_; }
      set {
        minRating_ = value;
      }
    }

    /// <summary>Field number for the "max_result_count" field.</summary>
    public const int MaxResultCountFieldNumber = 10;
    private int maxResultCount_;
    /// <summary>
    /// Maximum number of results to return. It must be between 1 and 20,
    /// inclusively. If the number is unset, it falls back to the upper limit. If
    /// the number is set to negative or exceeds the upper limit, an
    /// INVALID_ARGUMENT error is returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxResultCount {
      get { return maxResultCount_; }
      set {
        maxResultCount_ = value;
      }
    }

    /// <summary>Field number for the "price_levels" field.</summary>
    public const int PriceLevelsFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.PriceLevel> _repeated_priceLevels_codec
        = pb::FieldCodec.ForEnum(90, x => (int) x, x => (global::Google.Maps.Places.V1.PriceLevel) x);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.PriceLevel> priceLevels_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.PriceLevel>();
    /// <summary>
    /// Used to restrict the search to places that are marked as certain price
    /// levels. Users can choose any combinations of price levels. Default to
    /// select all price levels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.PriceLevel> PriceLevels {
      get { return priceLevels_; }
    }

    /// <summary>Field number for the "strict_type_filtering" field.</summary>
    public const int StrictTypeFilteringFieldNumber = 12;
    private bool strictTypeFiltering_;
    /// <summary>
    /// Used to set strict type filtering for included_type. If set to true, only
    /// results of the same type will be returned. Default to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StrictTypeFiltering {
      get { return strictTypeFiltering_; }
      set {
        strictTypeFiltering_ = value;
      }
    }

    /// <summary>Field number for the "location_bias" field.</summary>
    public const int LocationBiasFieldNumber = 13;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias locationBias_;
    /// <summary>
    /// The region to search. This location serves as a bias which means results
    /// around given location might be returned. Cannot be set along with
    /// location_restriction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias LocationBias {
      get { return locationBias_; }
      set {
        locationBias_ = value;
      }
    }

    /// <summary>Field number for the "location_restriction" field.</summary>
    public const int LocationRestrictionFieldNumber = 14;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction locationRestriction_;
    /// <summary>
    /// The region to search. This location serves as a restriction which means
    /// results outside given location will not be returned. Cannot be set along
    /// with location_bias.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction LocationRestriction {
      get { return locationRestriction_; }
      set {
        locationRestriction_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchTextRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchTextRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TextQuery != other.TextQuery) return false;
      if (LanguageCode != other.LanguageCode) return false;
      if (RegionCode != other.RegionCode) return false;
      if (RankPreference != other.RankPreference) return false;
      if (!object.Equals(Location, other.Location)) return false;
      if (IncludedType != other.IncludedType) return false;
      if (OpenNow != other.OpenNow) return false;
      if (!object.Equals(PriceRange, other.PriceRange)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MinRating, other.MinRating)) return false;
      if (MaxResultCount != other.MaxResultCount) return false;
      if(!priceLevels_.Equals(other.priceLevels_)) return false;
      if (StrictTypeFiltering != other.StrictTypeFiltering) return false;
      if (!object.Equals(LocationBias, other.LocationBias)) return false;
      if (!object.Equals(LocationRestriction, other.LocationRestriction)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TextQuery.Length != 0) hash ^= TextQuery.GetHashCode();
      if (LanguageCode.Length != 0) hash ^= LanguageCode.GetHashCode();
      if (RegionCode.Length != 0) hash ^= RegionCode.GetHashCode();
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) hash ^= RankPreference.GetHashCode();
      if (location_ != null) hash ^= Location.GetHashCode();
      if (IncludedType.Length != 0) hash ^= IncludedType.GetHashCode();
      if (OpenNow != false) hash ^= OpenNow.GetHashCode();
      if (priceRange_ != null) hash ^= PriceRange.GetHashCode();
      if (MinRating != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MinRating);
      if (MaxResultCount != 0) hash ^= MaxResultCount.GetHashCode();
      hash ^= priceLevels_.GetHashCode();
      if (StrictTypeFiltering != false) hash ^= StrictTypeFiltering.GetHashCode();
      if (locationBias_ != null) hash ^= LocationBias.GetHashCode();
      if (locationRestriction_ != null) hash ^= LocationRestriction.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TextQuery.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TextQuery);
      }
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RegionCode);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RankPreference);
      }
      if (location_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Location);
      }
      if (IncludedType.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(IncludedType);
      }
      if (OpenNow != false) {
        output.WriteRawTag(56);
        output.WriteBool(OpenNow);
      }
      if (priceRange_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(PriceRange);
      }
      if (MinRating != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(MinRating);
      }
      if (MaxResultCount != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(MaxResultCount);
      }
      priceLevels_.WriteTo(output, _repeated_priceLevels_codec);
      if (StrictTypeFiltering != false) {
        output.WriteRawTag(96);
        output.WriteBool(StrictTypeFiltering);
      }
      if (locationBias_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(LocationBias);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LocationRestriction);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TextQuery.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TextQuery);
      }
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RegionCode);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RankPreference);
      }
      if (location_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Location);
      }
      if (IncludedType.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(IncludedType);
      }
      if (OpenNow != false) {
        output.WriteRawTag(56);
        output.WriteBool(OpenNow);
      }
      if (priceRange_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(PriceRange);
      }
      if (MinRating != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(MinRating);
      }
      if (MaxResultCount != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(MaxResultCount);
      }
      priceLevels_.WriteTo(ref output, _repeated_priceLevels_codec);
      if (StrictTypeFiltering != false) {
        output.WriteRawTag(96);
        output.WriteBool(StrictTypeFiltering);
      }
      if (locationBias_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(LocationBias);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LocationRestriction);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TextQuery.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TextQuery);
      }
      if (LanguageCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegionCode);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RankPreference);
      }
      if (location_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Location);
      }
      if (IncludedType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IncludedType);
      }
      if (OpenNow != false) {
        size += 1 + 1;
      }
      if (priceRange_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PriceRange);
      }
      if (MinRating != 0D) {
        size += 1 + 8;
      }
      if (MaxResultCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxResultCount);
      }
      size += priceLevels_.CalculateSize(_repeated_priceLevels_codec);
      if (StrictTypeFiltering != false) {
        size += 1 + 1;
      }
      if (locationBias_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocationBias);
      }
      if (locationRestriction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocationRestriction);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchTextRequest other) {
      if (other == null) {
        return;
      }
      if (other.TextQuery.Length != 0) {
        TextQuery = other.TextQuery;
      }
      if (other.LanguageCode.Length != 0) {
        LanguageCode = other.LanguageCode;
      }
      if (other.RegionCode.Length != 0) {
        RegionCode = other.RegionCode;
      }
      if (other.RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        RankPreference = other.RankPreference;
      }
      if (other.location_ != null) {
        if (location_ == null) {
          Location = new global::Google.Maps.Places.V1.SearchTextRequest.Types.Location();
        }
        Location.MergeFrom(other.Location);
      }
      if (other.IncludedType.Length != 0) {
        IncludedType = other.IncludedType;
      }
      if (other.OpenNow != false) {
        OpenNow = other.OpenNow;
      }
      if (other.priceRange_ != null) {
        if (priceRange_ == null) {
          PriceRange = new global::Google.Maps.Places.V1.Int32Range();
        }
        PriceRange.MergeFrom(other.PriceRange);
      }
      if (other.MinRating != 0D) {
        MinRating = other.MinRating;
      }
      if (other.MaxResultCount != 0) {
        MaxResultCount = other.MaxResultCount;
      }
      priceLevels_.Add(other.priceLevels_);
      if (other.StrictTypeFiltering != false) {
        StrictTypeFiltering = other.StrictTypeFiltering;
      }
      if (other.locationBias_ != null) {
        if (locationBias_ == null) {
          LocationBias = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias();
        }
        LocationBias.MergeFrom(other.LocationBias);
      }
      if (other.locationRestriction_ != null) {
        if (locationRestriction_ == null) {
          LocationRestriction = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction();
        }
        LocationRestriction.MergeFrom(other.LocationRestriction);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            TextQuery = input.ReadString();
            break;
          }
          case 18: {
            LanguageCode = input.ReadString();
            break;
          }
          case 26: {
            RegionCode = input.ReadString();
            break;
          }
          case 32: {
            RankPreference = (global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference) input.ReadEnum();
            break;
          }
          case 42: {
            if (location_ == null) {
              Location = new global::Google.Maps.Places.V1.SearchTextRequest.Types.Location();
            }
            input.ReadMessage(Location);
            break;
          }
          case 50: {
            IncludedType = input.ReadString();
            break;
          }
          case 56: {
            OpenNow = input.ReadBool();
            break;
          }
          case 66: {
            if (priceRange_ == null) {
              PriceRange = new global::Google.Maps.Places.V1.Int32Range();
            }
            input.ReadMessage(PriceRange);
            break;
          }
          case 73: {
            MinRating = input.ReadDouble();
            break;
          }
          case 80: {
            MaxResultCount = input.ReadInt32();
            break;
          }
          case 90:
          case 88: {
            priceLevels_.AddEntriesFrom(input, _repeated_priceLevels_codec);
            break;
          }
          case 96: {
            StrictTypeFiltering = input.ReadBool();
            break;
          }
          case 106: {
            if (locationBias_ == null) {
              LocationBias = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias();
            }
            input.ReadMessage(LocationBias);
            break;
          }
          case 114: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TextQuery = input.ReadString();
            break;
          }
          case 18: {
            LanguageCode = input.ReadString();
            break;
          }
          case 26: {
            RegionCode = input.ReadString();
            break;
          }
          case 32: {
            RankPreference = (global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference) input.ReadEnum();
            break;
          }
          case 42: {
            if (location_ == null) {
              Location = new global::Google.Maps.Places.V1.SearchTextRequest.Types.Location();
            }
            input.ReadMessage(Location);
            break;
          }
          case 50: {
            IncludedType = input.ReadString();
            break;
          }
          case 56: {
            OpenNow = input.ReadBool();
            break;
          }
          case 66: {
            if (priceRange_ == null) {
              PriceRange = new global::Google.Maps.Places.V1.Int32Range();
            }
            input.ReadMessage(PriceRange);
            break;
          }
          case 73: {
            MinRating = input.ReadDouble();
            break;
          }
          case 80: {
            MaxResultCount = input.ReadInt32();
            break;
          }
          case 90:
          case 88: {
            priceLevels_.AddEntriesFrom(ref input, _repeated_priceLevels_codec);
            break;
          }
          case 96: {
            StrictTypeFiltering = input.ReadBool();
            break;
          }
          case 106: {
            if (locationBias_ == null) {
              LocationBias = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias();
            }
            input.ReadMessage(LocationBias);
            break;
          }
          case 114: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SearchTextRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// How results will be ranked in the response.
      /// </summary>
      public enum RankPreference {
        /// <summary>
        /// RankPreference value not set. Will default to DISTANCE.
        /// </summary>
        [pbr::OriginalName("RANK_PREFERENCE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Ranks results by distance.
        /// </summary>
        [pbr::OriginalName("DISTANCE")] Distance = 1,
        /// <summary>
        /// Ranks results by relevance. Sort order determined by normal ranking
        /// stack. See SortRefinement::RELEVANCE.
        /// </summary>
        [pbr::OriginalName("RELEVANCE")] Relevance = 2,
      }

      /// <summary>
      /// The region to search.
      ///
      /// Deprecated. Use LocationRestriction or LocationBias instead.
      /// </summary>
      public sealed partial class Location : pb::IMessage<Location>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Location> _parser = new pb::MessageParser<Location>(() => new Location());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Location> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchTextRequest.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Location() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Location(Location other) : this() {
          strictRestriction_ = other.strictRestriction_;
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              Rectangle = other.Rectangle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Location Clone() {
          return new Location(this);
        }

        /// <summary>Field number for the "rectangle" field.</summary>
        public const int RectangleFieldNumber = 1;
        /// <summary>
        /// A rectangle box defined by northeast and southwest corner.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Geo.Type.Viewport Rectangle {
          get { return typeCase_ == TypeOneofCase.Rectangle ? (global::Google.Geo.Type.Viewport) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rectangle;
          }
        }

        /// <summary>Field number for the "strict_restriction" field.</summary>
        public const int StrictRestrictionFieldNumber = 2;
        private bool strictRestriction_;
        /// <summary>
        /// Make location field a strict restriction and filter out POIs outside of
        /// the given location. If location type field is unset this field will have
        /// no effect.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool StrictRestriction {
          get { return strictRestriction_; }
          set {
            strictRestriction_ = value;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Rectangle = 1,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Location);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Location other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Rectangle, other.Rectangle)) return false;
          if (StrictRestriction != other.StrictRestriction) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Rectangle) hash ^= Rectangle.GetHashCode();
          if (StrictRestriction != false) hash ^= StrictRestriction.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (StrictRestriction != false) {
            output.WriteRawTag(16);
            output.WriteBool(StrictRestriction);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (StrictRestriction != false) {
            output.WriteRawTag(16);
            output.WriteBool(StrictRestriction);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Rectangle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rectangle);
          }
          if (StrictRestriction != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Location other) {
          if (other == null) {
            return;
          }
          if (other.StrictRestriction != false) {
            StrictRestriction = other.StrictRestriction;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              if (Rectangle == null) {
                Rectangle = new global::Google.Geo.Type.Viewport();
              }
              Rectangle.MergeFrom(other.Rectangle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 16: {
                StrictRestriction = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 16: {
                StrictRestriction = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// The region to search. This location serves as a bias which means results
      /// around given location might be returned.
      /// </summary>
      public sealed partial class LocationBias : pb::IMessage<LocationBias>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocationBias> _parser = new pb::MessageParser<LocationBias>(() => new LocationBias());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocationBias> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchTextRequest.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias(LocationBias other) : this() {
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              Rectangle = other.Rectangle.Clone();
              break;
            case TypeOneofCase.Circle:
              Circle = other.Circle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias Clone() {
          return new LocationBias(this);
        }

        /// <summary>Field number for the "rectangle" field.</summary>
        public const int RectangleFieldNumber = 1;
        /// <summary>
        /// A rectangle box defined by northeast and southwest corner.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Geo.Type.Viewport Rectangle {
          get { return typeCase_ == TypeOneofCase.Rectangle ? (global::Google.Geo.Type.Viewport) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rectangle;
          }
        }

        /// <summary>Field number for the "circle" field.</summary>
        public const int CircleFieldNumber = 2;
        /// <summary>
        /// A circle defined by center point and radius.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.Circle Circle {
          get { return typeCase_ == TypeOneofCase.Circle ? (global::Google.Maps.Places.V1.Circle) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Circle;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Rectangle = 1,
          Circle = 2,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocationBias);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocationBias other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Rectangle, other.Rectangle)) return false;
          if (!object.Equals(Circle, other.Circle)) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Rectangle) hash ^= Rectangle.GetHashCode();
          if (typeCase_ == TypeOneofCase.Circle) hash ^= Circle.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Rectangle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Circle);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocationBias other) {
          if (other == null) {
            return;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              if (Rectangle == null) {
                Rectangle = new global::Google.Geo.Type.Viewport();
              }
              Rectangle.MergeFrom(other.Rectangle);
              break;
            case TypeOneofCase.Circle:
              if (Circle == null) {
                Circle = new global::Google.Maps.Places.V1.Circle();
              }
              Circle.MergeFrom(other.Circle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// The region to search. This location serves as a restriction which means
      /// results outside given location will not be returned.
      /// </summary>
      public sealed partial class LocationRestriction : pb::IMessage<LocationRestriction>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocationRestriction> _parser = new pb::MessageParser<LocationRestriction>(() => new LocationRestriction());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocationRestriction> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchTextRequest.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction(LocationRestriction other) : this() {
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              Rectangle = other.Rectangle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction Clone() {
          return new LocationRestriction(this);
        }

        /// <summary>Field number for the "rectangle" field.</summary>
        public const int RectangleFieldNumber = 1;
        /// <summary>
        /// A rectangle box defined by northeast and southwest corner.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Geo.Type.Viewport Rectangle {
          get { return typeCase_ == TypeOneofCase.Rectangle ? (global::Google.Geo.Type.Viewport) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rectangle;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Rectangle = 1,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocationRestriction);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocationRestriction other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Rectangle, other.Rectangle)) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Rectangle) hash ^= Rectangle.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Rectangle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rectangle);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocationRestriction other) {
          if (other == null) {
            return;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              if (Rectangle == null) {
                Rectangle = new global::Google.Geo.Type.Viewport();
              }
              Rectangle.MergeFrom(other.Rectangle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Response proto for SearchText.
  /// </summary>
  public sealed partial class SearchTextResponse : pb::IMessage<SearchTextResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchTextResponse> _parser = new pb::MessageParser<SearchTextResponse>(() => new SearchTextResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchTextResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextResponse(SearchTextResponse other) : this() {
      places_ = other.places_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextResponse Clone() {
      return new SearchTextResponse(this);
    }

    /// <summary>Field number for the "places" field.</summary>
    public const int PlacesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.Place> _repeated_places_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.Places.V1.Place.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.Place> places_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.Place>();
    /// <summary>
    /// A list of places that meet the user's text search criteria.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.Place> Places {
      get { return places_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchTextResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchTextResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!places_.Equals(other.places_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= places_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      places_.WriteTo(output, _repeated_places_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      places_.WriteTo(ref output, _repeated_places_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += places_.CalculateSize(_repeated_places_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchTextResponse other) {
      if (other == null) {
        return;
      }
      places_.Add(other.places_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            places_.AddEntriesFrom(input, _repeated_places_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            places_.AddEntriesFrom(ref input, _repeated_places_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
